\chapter{実装}
\label{chap:implementation}
本章では，mROS 2-POSIXとROS 2の性能を比較評価するにあたって，mROS 2-POSIXとROS 2に実装するアプリケーションの概要と，これまで実装予定だったものについて説明する．
\section{実装アプリケーションの概要}
\label{chap:evaluation}章で述べたように，実装するアプリケーションの条件として，Pub-Sub通信のみを使用したアプリケーションであること，組み込みデバイス上で動作できるアプリケーションであること，エンドツーエンドのアプリケーションであることを設けた．
これらの条件を満たすアプリケーションとして，Wii Fit BoardとRaspimouseを用いたロボットの動作を制御するアプリケーションを実装する．
Raspimouseとは，ロボット開発キットであるRaspberry Pi Mouseのことで，Raspberry Pi上で動作するROS 2のノードで制御することができる．
Wii Fit Boardは，任天堂が発売したWiiの周辺機器で，体重移動を検知することができる．
このアプリケーションは，Wii Fit BoardからのセンサデータをRaspimouseにPub-Sub通信を用いて送信し，Raspimouseは受信したセンサデータをもとに動作を制御する．
ユーザの体重移動によってロボットが動作するため，エンドツーエンドのアプリケーションである．
また，Raspimouse上でノードを立ち上げ動作しているため，組み込みデバイス上で動作するアプリケーションという条件も満たしている．
\section{実装予定だったアプリケーション}
評価実験に用いるアプリケーションとして，Wii Fit BoardとRaspimouseを用いたロボットの動作を制御するアプリケーションを実装するが，本来は，Wii Fit BoardからのセンサデータをSphero sprk +にPub-Sub通信を用いて送信し，Sphero sprk +は受信したセンサデータをもとに動作を制御するアプリケーションを実装する予定だった．
Sphero sprk +は，Sphero社が発売した球体のロボットで，ユーザーがスマートフォンから操作することができる．
ROS 2側ではWii Fit Boardからのセンサデータを受け取り，Sphero sprk +に送信する２つのノードを実装することに成功したが，mROS 2-POSIX側ではWii Fit Boardからセンサデータを送信するノードを完成させることができたものの，Sphero sprk +を受信したセンサデータをもとに動作させるノードの作成が難しく，実装を断念した．
実装を断念した理由として，ROS 2側の実装ではSphero sprk +はPythonのライブラリを用いて制御しており，mROS 2-POSIXはPythonのSupportはないため，動作させるには，PythonのライブラリをC++言語に変換する必要があった．
しかし，PythonのライブラリをC++言語に変換するためには，bluezを用いてSphero sprk +をBLEサーバーと見立てたクライアントのスクリプトを実装する必要があり，その実装が間に合わないと判断したため，実装を断念した．
また，Sphero sprk +を動作させるライブラリはgo言語にもあったため，cgoと呼ばれるgo言語からC言語の関数を呼び出すための仕組みを用いて，go言語からSphero sprk +を動作させることも試みたが，mROS 2-POSIXのcgo移植になってしまい，実装範囲が広くなってしまったため，実装を断念した．
\section{実装アプリケーションの詳細}
実装アプリケーションはROS 2とmROS 2-POSIXの２つの環境で動作する．
ROS 2側のアプリケーションは，C++言語でWii Fit Boardのセンサの値をパブリッシュするノードを実装した．
センサの値をパブリッシュするためには，Wii Fit Boardを端末とBluetooth接続する必要がある．
接続後は/devにある/event○○を開くことでWii Fit Boardのセンサ値を取得できる．しかし，/eventはネットワーク環境によってランダムな/event番号に振り分けられるため，実行するネットワーク環境に変更があるたびに修正しなくてはならない．
また，ノード実行前に/dev/uinputにchmodでa+rwの権限を与えておく必要がある．
Wii Fit Boardはそれぞれの角に４つのセンサがあり，センサの値を/eventから４つの値が取得できる．
この値をこのままパブリッシュすると，サブスクライブする側で４つの値を処理しなくてはならないので，この４つの値をx,yの２つの値に変換する．
x,yはユーザの重心点を表しており，Boardに乗っているユーザの体重に応じてその大きさが変化する．
次に，x,yの値をサブスクライブするノードではパブリッシュされたx,yの値を受け取り，x,yの値に応じてRaspimouseの動作を制御する処理を実装した．
x,yの値はそれぞれユーザの体重によって大きく増減するため，適切な閾値の値はユーザーによって変化する．
今回の場合は，評価実験するユーザーとして開発者のみになるため，開発者の体重に合わせた閾値の値を設定した．
ロボットが動作する処理は，x,yの値が閾値を超えた場合にRaspimouseが動作するように実装した．
ユーザーがロボットを前進させようとした時，yの値がマイナスに大きく傾くため，yの値がマイナスの閾値を超えた場合にRaspimouseが前進するように実装した．
同様に，yの値がプラスに傾くとき，ロボットを後退させ，xの値がマイナスに傾くときにロボットを右に移動させ，プラスに傾くときにロボットを左に移動させるように実装を行った．
ロボットを移動させる処理はロボットのデバイスドライバを直接write命令を用いてたたくことで実装を行っている．
mROS 2-POSIX側のアプリケーションは，ROS 2側のアプリケーションと大きく変更されていない．
ROS 2側のアプリケーションと同様にWii Fit Boardのセンサの値をパブリッシュするノードを実装し，



