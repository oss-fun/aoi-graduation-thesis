\chapter{実装}
%ラズパイマウスのfollowerノードについての実装を書く．今はspheroとラズパイマウスのwiibordを本実装として話しているため改変が必要．aproachに持っていく．
\label{chap:implementation}
本章では，mROS 2-POSIXとROS 2の性能を比較評価するにあたって，mROS 2-POSIXとROS 2に実装するアプリケーションの概要と，これまで実装予定だったものについて説明する．
\section{実装アプリケーションの概要}
\label{chap:evaluation}章で述べたように，実装するアプリケーションの条件として，Pub-Sub通信のみを使用したアプリケーションであること，組み込みデバイス上で動作できるアプリケーションであること，エンドツーエンドのアプリケーションであることを設けた．
これらの条件を満たすアプリケーションとして，Wii Fit BoardとRaspimouseを用いたロボットの動作を制御するアプリケーションを実装する．
Raspimouseとは，ロボット開発キットであるRaspberry Pi Mouseのことで，Raspberry Pi上で動作するROS 2のノードで制御することができる．
Wii Fit Boardは，任天堂が発売したWiiの周辺機器で，体重移動を検知することができる．
このアプリケーションは，Wii Fit BoardからのセンサデータをRaspimouseにPub-Sub通信を用いて送信し，Raspimouseは受信したセンサデータをもとに動作を制御する．
ユーザの体重移動によってロボットが動作するため，エンドツーエンドのアプリケーションである．
また，Raspimouse上でノードを立ち上げ動作しているため，組み込みデバイス上で動作するアプリケーションという条件も満たしている．
\section{実装予定だったアプリケーション}
評価実験に用いるアプリケーションとして，Wii Fit BoardとRaspimouseを用いたロボットの動作を制御するアプリケーションを実装するが，本来は，Wii Fit BoardからのセンサデータをSphero sprk +にPub-Sub通信を用いて送信し，Sphero sprk +は受信したセンサデータをもとに動作を制御するアプリケーションを実装する予定だった．
Sphero sprk +は，Sphero社が発売した球体のロボットで，ユーザーがスマートフォンから操作することができる．
ROS 2側ではWii Fit Boardからのセンサデータを受け取り，Sphero sprk +に送信する２つのノードを実装することに成功したが，mROS 2-POSIX側ではWii Fit Boardからセンサデータを送信するノードを完成させることができたものの，Sphero sprk +を受信したセンサデータをもとに動作させるノードの作成が難しく，実装を断念した．
実装を断念した理由として，ROS 2側の実装ではSphero sprk +はPythonのライブラリを用いて制御しており，mROS 2-POSIXはPythonのSupportはないため，動作させるには，PythonのライブラリをC++言語に変換する必要があった．
しかし，PythonのライブラリをC++言語に変換するためには，bluezを用いてSphero sprk +をBLEサーバーと見立てたクライアントのスクリプトを実装する必要があり，その実装が間に合わないと判断したため，実装を断念した．
また，Sphero sprk +を動作させるライブラリはgo言語にもあったため，cgoと呼ばれるgo言語からC言語の関数を呼び出すための仕組みを用いて，go言語からSphero sprk +を動作させることも試みたが，mROS 2-POSIXのcgo移植になってしまい，実装範囲が広くなってしまったため，実装を断念した．
\section{実装アプリケーションの詳細}
実装アプリケーションはROS 2とmROS 2-POSIXの２つの環境で動作する．
ROS 2側のアプリケーションは，C++言語でWii Fit Boardのセンサの値をパブリッシュするノードを実装した．
センサの値をパブリッシュするためには，Wii Fit Boardを端末とBluetooth接続する必要がある．
接続後は/devにある/event○○を開くことでWii Fit Boardのセンサ値を取得できる．しかし，/eventはネットワーク環境によってランダムな/event番号に振り分けられるため，実行するネットワーク環境に変更があるたびに修正しなくてはならない．
また，ノード実行前に/dev/uinputにchmodでa+rwの権限を与えておく必要がある．
Wii Fit Boardはそれぞれの角に４つのセンサがあり，センサの値を/eventから４つの値が取得できる．
この値をこのままパブリッシュすると，サブスクライブする側で４つの値を処理しなくてはならないので，この４つの値をx,yの２つの値に変換する．
x,yはユーザの重心点を表しており，Boardに乗っているユーザの体重に応じてその大きさが変化する．
次に，x,yの値をサブスクライブするノードではパブリッシュされたx,yの値を受け取り，x,yの値に応じてRaspimouseの動作を制御する処理を実装した．
x,yの値はそれぞれユーザの体重によって大きく増減するため，適切な閾値の値はユーザーによって変化する．
今回の場合は，評価実験するユーザーとして開発者のみになるため，開発者の体重に合わせた閾値の値を設定した．
ロボットが動作する処理は，x,yの値が閾値を超えた場合にRaspimouseが動作するように実装した．
ユーザーがロボットを前進させようとした時，yの値がマイナスに大きく傾くため，yの値がマイナスの閾値を超えた場合にRaspimouseが前進するように実装した．
同様に，yの値がプラスに傾くとき，ロボットを後退させ，xの値がマイナスに傾くときにロボットを右に移動させ，プラスに傾くときにロボットを左に移動させるように実装を行った．
ロボットを移動させる処理はロボットのデバイスドライバを直接write命令を用いてたたくことで実装を行っている．
mROS 2-POSIX側のアプリケーションは，ROS 2側のアプリケーションと大きく変更されていない．
ROS 2側のアプリケーションと同様にWii Fit Boardのセンサの値をパブリッシュするノードを実装し，その値をサブスクライブするノードを実装した．
パブリッシュするノードではROS 2側と同様の実装になっている．異なる点はROS 2側ではrclcppと呼ばれるROS 2のノードを作成するためのインターフェースを使用しているが，mROS 2ではオリジナルのインターフェースが用意されている．
\section{実装に際しての課題と解決方法}
実装に際しての課題としてWii Fit Boardの値をパブリッシュするノードとその値をサブスクライブし，Raspimouseを動作させるノードそれぞれであった．
Wii Fit Boardの値をパブリッシュするノードでは，mROS 2-POSIX側のノードで実行後にSegment Faultが発生した．
mROS 2-POSIXを利用していると，ビルドが通って実行時にPub-Sub通信の準備が完了した後，Segment Faultが発生することがある．
これによって，ノードが突然動作しなくなる問題があったが，再度ビルドすることで修正することができた．
Wii Fit Boardのセンサの値をパブリッシュするノードからサブスクライブするノードでは，Raspimouseを動作させる部分で課題があった．
Raspimouseを制御する方法としてROS 2を利用する方法が一般的である．方法としては，Raspimouseの制御ノードを立ち上げ，制御ノードがパブリッシュしているトピックを別のノードでサブスクライブしたり，制御ノードがサブスクライブしているトピック宛に値をパブリッシュすることでRaspimouseを操作する．
すでにキーボードやゲームコントローラを使ってRaspimouseを操作できるノードも配布されている．
このRaspimouseの操作だがROS 2側では操作できるノードが配布されているため，比較的容易に動作させることができた．
しかし，mROS 2-POSIX側でRaspimouseの制御ノードであるROS 2のトピックに対してパブリッシュを動作させることができなかった．制御ノードがパブリッシュしている値のサブスクライブは問題なくmROS 2-POSIX側で可能であった．
制御ノードに対してmROS 2-POSIXからのパブリッシュが通らない理由として，QoS設定の問題がある．

\section{実装アプリケーション変更に伴って生じる影響}


